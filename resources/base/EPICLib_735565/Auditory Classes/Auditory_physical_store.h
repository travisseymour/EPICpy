#ifndef AUDITORY_PHYSICAL_STORE_H
#define AUDITORY_PHYSICAL_STORE_H

/*
The Auditory_physical_store holds Auditory_physical streams and sounds, and represents the state of affairs 
"on the skin" of the human. This interface represents e.g. the sound energy impinging on the human, 
independently of whether the ear (or the rest of the auditory system) can hear it or not. 

The external device causes the creation, modification, and destruction of physical_streams 
and sounds via direct calls to the Auditory_physical_store. 
Since the device supplies inputs in terms of its physical name, this is where we finesse 
how auditory psychological sounds and streams objects are identified with physical ones

This decouples the simulated Human from Device, in that this interface keeps its own copy of
the physical situation generated by the Device.

The Auditory_physical_store will update its representation of the objects and then do a
direct call of the Ear_processor to act on that change. 
It creates the psychological names here, using a name-in-advance scheme, to facilitate
making links between separate sound inputs.
*/

#include "Auditory_store.h"
//#include "Human_subprocessor.h"
#include "../Framework classes/Name_map.h"
#include "../Utility Classes/Symbol.h"
#include "../Utility Classes/Geometry.h"
namespace GU = Geometry_Utilities;
//#include "Output_tee.h"

struct Speech_word;

// An Auditory_physical_stream is an Auditory_stream with additional members to help us 
// construct the links to the next sound

class Auditory_physical_stream : public Auditory_stream {
public:
	static Smart_Pointer<Auditory_stream> create(const Symbol& name, GU::Point location, GU::Size size = GU::Size())
				{return new Auditory_physical_stream(name, location, size);}
/*	sound name functionality disabled 5/7/12
	virtual Symbol create_next_sound_name();
	virtual Symbol get_next_sound_name() const
		{return next_sound_name;}
*/	
	void display_contents(Output_tee& ot) const;
	
protected:
//	long sound_name_counter;	// counts sounds associated with this stream
//	Symbol next_sound_name;

private:
	Auditory_physical_stream(const Symbol& name, GU::Point location, GU::Size size);
	
	// no default copy, assignment
	Auditory_physical_stream(const Auditory_stream&);
	Auditory_physical_stream& operator= (const Auditory_stream&);
	
};




/* Auditory_physical_store
This is a processor that contains a container of Auditory streams and sounds.
New streams and sounds result in the creation of new objects with assigned  psychological names. 
The device can add or modify objects directly, and the result is a direct call
to the Ear_processor.
*/

class Auditory_physical_store : public Auditory_store {
public:
	Auditory_physical_store(Human_processor * human_ptr_) :
		Auditory_store("Auditory_physical_store", human_ptr_), 
		stream_counter(0), speech_item_counter(0)
		{}

	virtual void initialize();
	
	/* direct inputs - 
	   object name is supplied along with all relevant information - no backwards lookup necessary
	   returns true if a change was made to data base (and so input should be processed further) and false otherwise.
	   Some functions return the previous value, and do nothing unless it is different from the new value.
	*/
	// auditory stream inputs
	virtual GU::Point set_stream_location(const Symbol& name, GU::Point location);
	virtual GU::Size set_stream_size(const Symbol& name, GU::Size size);
	virtual Symbol set_stream_property(const Symbol& name, const Symbol& propname, const Symbol& propvalue);

	// sound inputs
	// physical interface
	virtual void make_sound_start(const Symbol& name, const Symbol& stream_name, GU::Point location, const Symbol& timbre, double loudness, long intrinsic_duration);
//	virtual void make_speech_start(const Symbol& physical_name, const Symbol& stream_name,  
//		const Symbol& content, const Symbol& speaker_gender, const Symbol& speaker_id, double loudness, long duration);
	virtual void make_speech_start(const Speech_word& word);
	virtual void make_sound_stop(const Symbol& name);	
	virtual void make_sound_event(const Symbol& name, const Symbol& stream_name, GU::Point location, const Symbol& timbre, double loudness, long duration, long intrinsic_duration = 0);

//	sound_name, stream_name - to allow finesse of sound/stream object identity
//	content - finessed content of the speech object - e.g. recognized word
//	speaker_gender, speaker_id - surrogates/finesse of e.g. formant structure that distinguishes one speaker from another
//	loudness - in db - can be a cue to stream identification
//	duration - of this speech object
//	virtual void make_speech_event(const Symbol& sound_name, const Symbol& stream_name, 
//		const Symbol& content, const Symbol& speaker_gender, const Symbol& speaker_id, double loudness, long duration);
	virtual void make_speech_event(const Speech_word& word);
	virtual void erase_sound(const Symbol& name);
	virtual Symbol set_sound_property(const Symbol& name, const Symbol& propname, const Symbol& propvalue);

	// event interface - implemented to allow other components to "fire & forget" long-duration auditory inputs
	virtual void accept_event(const Auditory_event *);
	virtual void handle_event(const Auditory_Sound_Stop_event *);
	// handles events generated by Vocal_processor.
	virtual void handle_event(const Auditory_Speech_event *);

	// allow outsiders to access and modify the name map - e.g. to remove names
	Name_map& get_name_map()
		{return name_map;}

private:
	// state
	long stream_counter;	// counter for new stream identification symbols
	long speech_item_counter;	// counter for new speech input identification symbols
	
	Name_map name_map;
	
	virtual void create_stream(const Symbol& name, GU::Point location, GU::Size size = GU::Size(), bool propagate_new_stream = true);
	virtual void destroy_stream(const Symbol& name);
	Symbol create_sound_name(const Symbol& physical_name);
//	virtual void erase_stream(const Symbol& name);

	// no default copy, assignment
	Auditory_physical_store(const Auditory_physical_store&);
	Auditory_physical_store& operator= (const Auditory_physical_store&);
};

#endif
