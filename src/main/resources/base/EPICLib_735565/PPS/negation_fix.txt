10/4/04
At this time, I can now write many more interesting rules using negated conjunctions:

(Top_look_at_shape_unknown_color
If
(
	(Goal Do Visual_search)
	(Step Look_at Candidate)
	(Visual ?candidate Shape ?shape)
	(Tag ?shape probe_shape)
	(Not (Visual ?candidate Color ???)	// color must be unknown
	(Not (Tag ?other eligible)		// do not fire if complete match case is present
		 (Visual ?other Color ?color)
		 (Tag ?color probe_color)
		 (Visual ?other Shape ?shape)
		 (Tag ?shape probe_shape)
		 )
	(Not (Tag ?candidate probe_object))
	(Not (Tag ?candidate Fixation_point))
	(Motor Ocular Processor Free)
	(Randomly_choose_one)
)
Then
(
	(Add (Tag ?candidate candidate))
	(Send_to_motor Ocular Perform Move ?candidate)
	(Delete (Step Look_at Candidate))
	(Add (Step Waitfor Candidate))
))

But I have to generalize this further, because simply allowing negated conjunctions 
isn't quite enough to support the goal of single-cycle matches to mutually exclusive and 
exhaustive cases, where items are present or absent (as opposed to always being present
and having two different values). I need to be able to write rules like:


(Top_look_at_object_randomly
If
(
	(Goal Do Visual_search)
	(Step Look_at Candidate)
	(Visual ?candidate Status Visible)
	(Tag ?probe probe_object)
	(Visual ?object Color ???)
	(Tag ?object eligible)
	(Not (Tag ?other eligible)		// do not fire if complete match case is present
		 (Visual ?other Color ?color)
		 (Tag ?color probe_color)
		 (Visual ?other Shape ?shape)
		 (Tag ?shape probe_shape)
		 )
	(Not (Tag ?other2 eligible)		// do not fire if shape_unknown_color case is present
		 (Visual ?other2 Shape ?shape)
		 (Tag ?shape probe_shape)
		 (Not (Visual ?other2 Color ???))	// is true if other2 has a color, must make
		 									// embedded pattern false
		 )
	(Not (Tag ?candidate probe_object))
	(Not (Tag ?candidate Fixation_point))
	(Motor Ocular Processor Free)
	(Randomly_choose_one)
)
Then
(
	(Add (Tag ?candidate candidate))
	(Send_to_motor Ocular Perform Move ?candidate)
	(Delete (Step Look_at Candidate))
	(Add (Step Waitfor Candidate))
))

That is, the subpattern in the second (Not is supposed to function like the first,
by disabling this rule if the subpattern is matched. The subpattern matches for
an ?other2 that has the probe shape and whose color is missing. If present, 
it is supposed to trigger the _shape_unknown_color rule, and disable this rule.

I am willing to do this by enumerated cases
 - (Not single_clause)
 - (Not multiple clauses)
 where multiple clauses consist of either postive clauses or negated clauses.
 but no deeper embedding is allowed.
 
 But consider a fully recursive definition:
 
 rule condition -> pattern + predicate* // predicates must be top-level
 pattern -> (Clause + term*)	// at least one Clause (i.e. positive Clause) in a pattern
 term -> Clause | (Not pattern)
 
Possible patterns:
 (A)
 (A B C)
 Not allowed: (Not A) - nothing to subtract from!
 (A (Not B) C)
 (A (Not B C) D)
 (A (Not B C) (Not D) E)
 Not allowed: (A (Not (Not B))) - nothing to subtract from!
 (A (Not B (Not C)) )
 (A (Not B (Not C) D) E (Not F (Not G) H) I ) - should be sufficient
 	most embedded is a single-clause Not
 (A (Not B (Not C D) E) F)
 
 Must build a matching network for each pattern! - most embedded must be formed first!
 This would be easy except that the optimizer requires collecting the pair across levels of the pattern


-------
8/27/04 
-------
I think the basic (and only) problem (maybe) is that the combining of positive patterns is
not looking into the negated condition lists properly.

-------
Trying to figure out how to fix the negated conjunction because this should also support
a solution to other problems.

This is damn confusing!

Let's try to define this correctly:

(Not (Tag ?x A))

The inner clause matches any case where ?x is A. If there is one, that ?x is subtracted
from any bindings of ?x in the rest of the condition. If there are no appearances of ?x
in the rest of the condition, then the No_Overlap negation means that any bindings 
of ?x turn the negation node off, so none of the positive inputs are passed through.

So the following all are well defined and make sense:

(Test_x_not_x_A
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Tag ?x Object)
	(Not (Tag ?x A))
	)
Then (
	(Log Test_x_not_x_A) // ?x binding appears
	(Delete (Step Fire Rules))
	)
)

(Test_y_not_x_A
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Tag ?y Object)
	(Not (Tag ?x A))
	)
Then (
	(Log Test_y_not_x_A)	// ?y binding appears
	(Delete (Step Fire Rules))
	)
)

(Test_not_x_A
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Not (Tag ?x A))
	)
Then (
	(Log Test_not_x_A)	// no binding appears in action
	(Delete (Step Fire Rules))
	)
)


OK, now what about if there is more than one clause in the negated pattern:

(Not (Tag ?x A)(Tag ?x B))

The inner clauses should match any case where ?x is both A and B. If there is one,
that ?x should be subtracted from any bindings of ?x in the rest of the condition.
This case is identical in effect to two separate Not clauses:
(Not (Tag ?x A))
(Not (Tag ?x B))

But if there are no appearances of ?x in the rest of the condition, this means that
there should be a No-overlap negation node whose negative input is the result of 
an and node combining (Tag ?x A) and (Tag ?x B).

So the following should be well-defined and make sense:

(Test_x_not_x_A_not_x_B
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Tag ?x Object)
	(Not (Tag ?x A))
	(Not (Tag ?x B))
	)
Then (
	(Log Test_x_not_x_A) // ?x binding appears
	(Delete (Step Fire Rules))
	)
)

(Test_x_not_x_A_x_B
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Tag ?x Object)
	(Not (Tag ?x A)(Tag ?x B))
	)
Then (
	(Log Test_x_not_x_A_x_B) // ?x binding appears
	(Delete (Step Fire Rules))
	)
)
// above two are synonymous

(Test_y_not_x_A_not_x_B
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Tag ?y Object)
	(Not (Tag ?x A))
	(Not (Tag ?x B))
	)
Then (
	(Log Test_y_not_x_A_not_x_B) // ?y binding appears
	(Delete (Step Fire Rules))
	)
)
// above should fire only if nothing is A and nothing is B, but
// the two ?x's shouldn't communicate - 

(Test_y_not_x_A_x_B
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Tag ?y Object)
	(Not (Tag ?x A)(Tag ?x B))
	)
Then (
	(Log Test_y_not_x_A_x_B)	// ?y binding appears
	(Delete (Step Fire Rules))
	)
)
// above should fire only if there is nothing that is both A and B;
// something that is just A (or just B) shouldn't stop it.

(Test_not_x_A_not_x_B
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Not (Tag ?x A))
	(Not (Tag ?x B))
	)
Then (
	(Log Test_not_x_A_not_x_B)	// no binding appears in action
	(Delete (Step Fire Rules))
	)
)
// above should fire only if nothing is A and nothing is B, but
// the two ?x's shouldn't communicate - 

(Test_not_x_A_x_B
If (
	(Goal Do Test)
	(Step Fire Rules)
	(Not (Tag ?x A)(Tag ?x B))
	)
Then (
	(Log Test_not_x_A_x_B)	// no binding appears in action
	(Delete (Step Fire Rules))
	)
)

// above should fire only if there is nothing that is both A and B;
// something that is just A (or just B) shouldn't stop it.
